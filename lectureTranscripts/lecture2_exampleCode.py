
letterT = [0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
           0,  1,  1,  1,  1,  1,  1,  1,  1,  0,
           0,  1,  1,  1,  1,  1,  1,  1,  1,  0,
           0,  0,  0,  0,  1,  1,  0,  0,  0,  0,
           0,  0,  0,  0,  1,  1,  0,  0,  0,  0,
           0,  0,  0,  0,  1,  1,  0,  0,  0,  0,
           0,  0,  0,  0,  1,  1,  0,  0,  0,  0,
           0,  0,  0,  0,  1,  1,  0,  0,  0,  0,
           0,  0,  0,  0,  1,  1,  0,  0,  0,  0,
           0,  0,  0,  0,  1,  1,  0,  0,  0,  0,
           0,  0,  0,  0,  1,  1,  0,  0,  0,  0,
           0,  0,  0,  0,  0,  0,  0,  0,  0,  0]

def imageClassifier(letter):

    # Pick a label based on the data input
    predictedLabel = "Some Letter"

    return(predictedLabel)




def imageClassifier(letter):
    if(sum(letter) == 32):
        predictedLabel = "T"

    # Pick a label based on the data input

    return(predictedLabel)




def imageClassifier(letter):
    #Detect number of line intersections
    #(For the case of "T", this would be 1 intersection)
    intersections = 1

    if(intersections == 1):
        predictedLabel = "T"
    # Pick a label based on the data input

    return(predictedLabel)



def train(observedImages, humanLabels):
    #Teach the model all of the exceptions and rules
    return imageClassifier

def predict(imageClassifier, myNewImage):
    #Use the classifier
    return predictedLabel





def train(observedImages, humanLabels):
    


    return imageClassifier

def predict(imageClassifier, myNewImage):
    #Use the classifier
    return predictedLabel


letterT = [0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
           0,  1,  1,  1,  1,  1,  1,  1,  1,  0,
           0,  1,  1,  1,  1,  1,  1,  1,  1,  0,
           0,  0,  0,  0,  1,  1,  0,  0,  0,  0,
           0,  0,  0,  0,  1,  1,  0,  0,  0,  0,
           0,  0,  0,  0,  1,  1,  0,  0,  0,  0,
           0,  0,  0,  0,  1,  1,  0,  0,  0,  0,
           0,  0,  0,  0,  1,  1,  0,  0,  0,  0,
           0,  0,  0,  0,  1,  1,  0,  0,  0,  0,
           0,  0,  0,  0,  1,  1,  0,  0,  0,  0,
           0,  0,  0,  0,  1,  1,  0,  0,  0,  0,
           0,  0,  0,  0,  0,  0,  0,  0,  0,  0]


letterl = [0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
           0,  0,  0,  0,  1,  1,  0,  0,  0,  0,
           0,  0,  0,  0,  1,  1,  0,  0,  0,  0,
           0,  0,  0,  0,  1,  1,  0,  0,  0,  0,
           0,  0,  0,  0,  1,  1,  0,  0,  0,  0,
           0,  0,  0,  0,  1,  1,  0,  0,  0,  0,
           0,  0,  0,  0,  1,  1,  0,  0,  0,  0,
           0,  0,  0,  0,  1,  1,  0,  0,  0,  0,
           0,  0,  0,  0,  1,  1,  0,  0,  0,  0,
           0,  0,  0,  0,  1,  1,  0,  0,  0,  0,
           0,  0,  0,  0,  1,  1,  0,  0,  0,  0,
           0,  0,  0,  0,  0,  0,  0,  0,  0,  0]


letterI = [0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
           0,  1,  1,  1,  1,  1,  1,  1,  1,  0,
           0,  1,  1,  1,  1,  1,  1,  1,  1,  0,
           0,  0,  0,  0,  1,  1,  0,  0,  0,  0,
           0,  0,  0,  0,  1,  1,  0,  0,  0,  0,
           0,  0,  0,  0,  1,  1,  0,  0,  0,  0,
           0,  0,  0,  0,  1,  1,  0,  0,  0,  0,
           0,  0,  0,  0,  1,  1,  0,  0,  0,  0,
           0,  0,  0,  0,  1,  1,  0,  0,  0,  0,
           0,  1,  1,  1,  1,  1,  1,  1,  1,  0,
           0,  1,  1,  1,  1,  1,  1,  1,  1,  0,
           0,  0,  0,  0,  0,  0,  0,  0,  0,  0]


testedT = [0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
           0,  0,  1,  1,  1,  1,  1,  1,  0,  0,
           0,  0,  1,  1,  1,  1,  1,  1,  0,  0,
           0,  0,  1,  0,  1,  1,  0,  1,  0,  0,
           0,  0,  0,  0,  1,  1,  0,  0,  0,  0,
           0,  0,  0,  0,  1,  1,  0,  0,  0,  0,
           0,  0,  0,  0,  1,  1,  0,  0,  0,  0,
           0,  0,  0,  0,  1,  1,  0,  0,  0,  0,
           0,  0,  0,  0,  1,  1,  0,  0,  0,  0,
           0,  0,  0,  1,  1,  1,  1,  0,  0,  0,
           0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
           0,  0,  0,  0,  0,  0,  0,  0,  0,  0]


testedL = [0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
           0,  0,  0,  0,  1,  1,  0,  0,  0,  0,
           0,  0,  0,  0,  1,  1,  0,  0,  0,  0,
           0,  0,  0,  0,  1,  1,  0,  0,  0,  0,
           0,  0,  0,  0,  1,  1,  0,  0,  0,  0,
           0,  0,  0,  0,  1,  1,  0,  0,  0,  0,
           0,  0,  0,  0,  1,  1,  0,  0,  0,  0,
           0,  0,  0,  0,  1,  1,  0,  0,  0,  0,
           0,  0,  0,  0,  1,  1,  1,  0,  0,  0,
           0,  0,  0,  0,  1,  1,  1,  1,  0,  0,
           0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
           0,  0,  0,  0,  0,  0,  0,  0,  0,  0]


import numpy as np
def L1Norm(imageA, imageB):
    #print("Total number of black pixels in Image A: " + 
    #        str(np.sum(imageA)))

    #print("Total number of black pixels in Image B: " + 
    #        str(np.sum(imageB)))

    pixelWiseDiff = str(np.sum(np.abs(np.asarray(imageA) - np.asarray(imageB))))
    #print("Absolute pixelwise difference: " + 
    #        pixelWiseDiff)

    return(pixelWiseDiff)

L1Norm(letterT, testedT)

training = {}
training["T"] = letterT
training["l"] = letterl
training["I"] = letterI

predictLetter = testedT
estimates = {}
for l in training:
    distance = L1Norm(training[l], predictLetter)
    estimates[l] = distance



import numpy as np

#Make all of our training and test data into numpy arrays
#ALlows us to take advantage of speed gains and numerous built in
#functions more easily.


letterT = np.asarray(letterT)


letterI = np.asarray(letterI)
letterl = np.asarray(letterl)
testLetter = np.asarray(testedT)
testLetter2 = np.asarray(testedL)

class NearestNeighbor:
    def __init__(self):
        pass

    def train(self, X, y):
        #For nearest neighbor, we just copy the data for later use.
        self.Xtr = X
        self.ytr = y

    def predict(self, X):        
        #We'll be doing our test for every input X this time, 
        #just in case we want to test multiple
        #cases (As we'll be doing later!)
        
        #Create an empty list to hold our results
        #Note the dtype tells Numpy if the output (y) estimates
        #should be a float, integer, or string based on the training y.
        Ypred = np.zeros(len(X), dtype=np.dtype(self.ytr.dtype))

        for i in range(0, len(X)):
            l1Distances = np.sum(np.abs(self.Xtr - X[i]), axis=1)
            minimumDistance = np.argmin(l1Distances)
            Ypred[i] = self.ytr[minimumDistance]
        
        return Ypred



class NearestNeighborSinglePrediction:
    def __init__(self):
        pass

    def train(self, X, y):
        #For nearest neighbor, we just copy the data for later use.
        self.Xtr = X
        self.ytr = y

    def predict(self, X):        
        l1Distances = np.sum(np.abs(self.Xtr - X[0]), axis=1)
        minimumDistance = np.argmin(l1Distances)
        Ypred = self.ytr[minimumDistance]
        
        return Ypred



#Build our "Y" and "X" data for training - two lists as the primary paradigm:
trainingX = [letterT, letterI, letterl]
trainingy = np.array(["T", "I", "l"])

nn = NearestNeighbor()
nn.train(X=trainingX, y=trainingy)
estimates = nn.predict(X=[testLetter, testLetter2])

print(estimates)
